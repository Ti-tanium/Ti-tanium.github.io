<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单例模式的五种Java实现]]></title>
    <url>%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BA%94%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[定义单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 特点 单例类仅有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例 单例类的唯一实例必须由自己创建 避免对共享资源的多重占用 单例对象在堆上分配的内存空间只有在程序终止后才会释放（不要滥用单例） 使用场景 需频繁实例化/销毁的对象 有状态的工具类对象 频繁访问数据库/文件的对象 实例 网站的计数器采用单例模式，以保证同步。 windows的Recycle Bin（回收站）是典型的单例应用。 应用程序的日志应用一般用单例模式实现。由于共享的日志文件一直处于打开状态，只能有一个实例去操作，否则内容不好追加。 数据库连接池一般也是采用单例模式。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗 多线程的线程池一般采用单例模式 饿汉模式饿汉模式指的是，使用之前初始化，类加载时就完成了初始化 特点 类加载比较慢，会占用较多的内存 基于classloader的机制避免了同步问题 由于没有使用锁，执行效率高 代码12345678public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 懒汉式 Lazy Initialization指的是在用的时候才实例化，即懒加载。 特点 需要使用锁来保证线程安全，这会牺牲效率 代码12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 双重检查模式 第一次检查 避免没必要的同步，如果不是null的话，线程不会被阻塞，直接返回单例。 只有在单例是null的情况下，需要同步构建一个单例 第二次检查 由于进行了同步，在第一个进入临界区的线程建立单例后，为了防止后面其他被阻塞的线程重复创建单例，因此进行第二次检查：不为null就直接返回。 volatile保证有序性 由于singleton=new Singleton()语句不具有原子性，该语句可分为三步： 分配内存空间 初始化对象 将内存空间的地址赋给对应的引用 有可能指令重排后，初始化对象放在了最后一步，而此时singleton已经不是null了，因此可能有其他的线程成功跳过了第一次检查，返回了一个没有正确初始化的实例。而volatile可以禁止指令重排，保证所有线程都可以获取到正确实例化的单例对象。 123456789101112131415public class Singleton &#123; private volatile Singleton singleton; // volatile ensure executing order private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; // first check synchronized (Singleton.class) &#123; if (singleton == null) &#123; // second check singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 静态内部类模式 推荐使用 可以达到与DCL同样的效果，而且实现简单。 同步问题：利用了ClassLoader的机制避免了同步问题（classloader可以保证一个类只被加载一次） 懒加载：而静态内部类只在被调用的时候，才会被加载，因而保证了懒加载 123456789101112public class Singleton &#123; // Holder private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125;]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Singleton Pattern</tag>
        <tag>Thread Safe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序-mpvue+koa2框架搭建本地开发环境]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9Ampvue-koa2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[在本地搭建开发环境，方便开发进行 搭建mpvue环境 首先获取小程序AppIdAppId可去往微信公众平台获取，在设置一栏的开发设置下 2.初始化mpvue该步骤需要实现安装过nodejs，与vue，具体安装步骤见vuejs的三个安装方法 进入到项目目录后输入 vue init mpvue/mpvue-quickstart 然后根据提示逐步输入信息 project name 即项目名称 wxmp appid 即微信小程序appid，从微信公众平台中获得。 剩下的选项直接敲回车键即可。 3.安装依赖在项目目录下 输入 npm install Bug：在进行这一步的时候出现了一个问题，错误提示如下： 于是我开始使用管理身份运行cmd，继续install，但仍然出现同样的错误，这时候使用 npm cache clean —force清楚完npm的缓存后发现运行正常了，等待一段时间后得到如下结果 安装依赖完成，这一步在项目文件夹下下载了node_modules文件夹 4.使用微信小程序web开发工具打开项目 打开后即可看到mpvue的demo实例小程序 到这里说明mpvue弄好了。 二、搭建本地开发环境 1.下载demo地址：https://console.qcloud.com/lav2/dev 下载完成后将里面的server文件夹复制到项目的根目录下。 2.建立数据库使用mysql数据库 打开cmd窗口，cd到mysql的安装路径cd C:\Program Files\MySQL\MySQL Server 5.7\bin登录mysql数据库mysql -u root -p输入密码后进入数据库 建立数据库create database CAuth;建立名为CAuth的数据库，由于在server/config.js中已经配置好数据库，所以命名数据库为CAuth，若想用其他名字，也需要在config.js中对应修改，config.js文件中mysql的配置如下： /** MySQL 配置，用来存储 session 和用户信息 若使用了腾讯云微信小程序解决方案 开发环境下，MySQL 的初始密码为您的微信小程序 appid*/mysql: {host: ‘localhost’,port: 3306,user: ‘root’,db: ‘cAuth’,pass: ‘你数据库的密码’,char: ‘utf8mb4’},注意要对应修改pass，否则初始化数据库时会无法登录。 3.配置config.js在server/config.js中的CONF中添加如下代码： serverHost: ‘localhost’, tunnelServerUrl: ‘’, tunnelSignatureKey: ‘27fb7d1c161b7ca52d73cce0f1d833f9f5b5ec89’, // 腾讯云相关配置可以查看云 API 秘钥控制台：https://console.cloud.tencent.com/capi qcloudAppId: ‘您的腾讯云 AppID’, qcloudSecretId: ‘您的腾讯云 SecretId’, qcloudSecretKey: ‘您的腾讯云 SecretKey’, wxMessageToken: ‘weixinmsgtoken’, networkTimeout: 30000,修改以下三项，腾讯云相关配置可以查看云 API 秘钥控制台 4.初始化环境首先安装依赖 切换到服务端代码目录cd server 安装依赖npm install 安装全局依赖npm install -g nodemon 初始化数据库 node tools/initdb.js 5.测试本地环境是否搭建成功1.首先可以在server/controllers目录下新建test.js文件内容如下： module.exports = async (ctx) =&gt; { ctx.state.data={ msg:’hello 小程序后台’ }}2.然后在server/routes/index.js文件中添加一句 router.get(‘/test’,controllers.test)3.在cmd窗口中，cd到server文件夹下输入： npm run dev成功结果如下： 4.打开浏览器输入 http://localhost:5757/weapp/test 若看见下图 则说明配置成功。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JSONP简介]]></title>
    <url>%2FJSONP%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[JSONPJSONP(JSON with padding) 是一种跨域访问的机制。 跨域访问定义：跨域是指从一个域名的网页去请求另一个域名的资源。比如从http://www.baidu.com/ 页面去请求 http://www.google.com 的资源。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域。 跨站攻击传统上，浏览器的实现禁止 XMLHttpRequest 请求跨域访问，因为这样会引发安全问题，如跨站攻击。跨站攻击例： A网站通过以下请求发帖：http://example.com/bbs/create_post.php?title=标题&amp;content=内容 若Attacker在B网站发帖包含以下链接：http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈 则只要在B网站点了以上链接的victim，都会不知情的发帖。由于example网站保存了cookie，因此有victim的authentication 跨域使用场景有时公司内部有多个不同的子域，比如一个是location.company.com，而应用是放在app.company.com , 这时想从 app.company.com去访问 location.company.com 的资源就属于跨域。 如何跨域首先，要知道HTML中的&lt;script&gt;、&lt;img&gt; 标签的src属性是可以跨域访问的。JSONP正是利用了这一点进行跨域访问。 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 JSONP缺点 由于script标签仅支持get方法，因此JSONP也仅支持get请求 需要服务器配合返回指定格式的数据 简单实现 客户端 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。'); &#125;; //把callback函数赋给window对象，供script回调 window.flightHandler = flightHandler; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler"; // 创建script标签，设置其属性 var script = document.createElement('script'); script.setAttribute('src', url); // 把script标签加入head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 服务器 1234567891011121314151617181920var http = require('http');var urllib = require('url');var port = 8080;var data = &#123;'data':'world'&#125;;http.createServer(function(req,res)&#123; var params = urllib.parse(req.url,true); if(params.query.callback)&#123; console.log(params.query.callback); //jsonp var str = params.query.callback + '(' + JSON.stringify(data) + ')'; res.end(str); &#125; else &#123; res.end(); &#125; &#125;).listen(port,function()&#123; console.log('jsonp server is on');&#125;); JQuery实现$.getJSON123$.getJSON("http://crossdomain.com/services.php?callback=?", function(json)&#123; alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');&#125;); $.ajax12345678910111213$.ajax(&#123; type: "get", url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); AngularJS实现123456$http.jsonp('https://public-api.wordpress.com/rest/v1/sites/wtmpeachtest.wordpress.com/posts?callback=JSON_CALLBACK') .success(function(data)&#123; alert('success:'+data); &#125;).error(function(err)&#123; alert('error:'+err); &#125;);]]></content>
      <categories>
        <category>Front-end</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重排与重绘]]></title>
    <url>%2F%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98%2F</url>
    <content type="text"><![CDATA[浏览器渲染过程 解析HTML，生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树(Render Tree) Layout(排布):根据生成的渲染树，进行排布(Layout)，得到节点的几何信息（位置，大小） Painting(绘制):根据渲染树以及排布得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层） 重排与重绘任何改变用来构建渲染树的信息都会导致一次重排或重绘。 重排部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算 重绘由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新 注意： 重绘不一定导致重排，重排一定导致重绘 重排开销比重绘大 实例 重排 重绘 bstyle.padding = &quot;20px&quot;; ⭐ ⭐ bstyle.border = &quot;10px solid red&quot;; ⭐ ⭐ bstyle.color = &quot;blue&quot;; ⭐ bstyle.backgroundColor = &quot;#red&quot;; ⭐ bstyle.fontSize = &quot;2em&quot;; ⭐ ⭐ document.body.appendChild(document.createTextNode(&#39;dude!&#39;)); ⭐ ⭐ 浏览器尺寸发生改变 ⭐ ⭐ 元素位置或尺寸发生改变 ⭐ ⭐ 新增或删除可见元素 ⭐ ⭐ 激活CSS伪类 ⭐ ⭐ visibility、outline、background-color ⭐ 最小化重排重绘浏览器的优化浏览器会基于你的脚本要求创建一个变化的队列，然后分批去展现。通过这种方式许多需要一次重排的变化就会整合起来，最终只有一次重排会被计算渲染。浏览器可以向已有的队列中添加变更并在一个特定的时间或达到一个特定数量的变更后执行。 但是当程序员在代码中，需要直接获取样式信息时，为了提供最新的样式信息，浏览器被迫刷新队列，这时会引发一次重排重绘。 优化方法 不要逐个修改样式，通过改变类名或编辑cssText方式来修改 12345678910// bad var left = 10, top = 10; el.style.left = left + "px"; el.style.top = top + "px";// change class nameel.className += " theclassname";// edit cssTextel.style.cssText += "; left: " + left + "px; top: " + top + "px;"; 修改大量属性时，先通过display：none将元素隐藏（触发一次重排），批量修改完属性后再通过display显示出来（触发第二次重排），这样修改大量属性也只触发两次重排。 123456789101112function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById('list');ul.style.display = 'none';appendDataToElement(ul, data);ul.style.display = 'block'; 使用文档片段（Document Fragment），构建子树，在子树中修改，完成后再接入DOM中 1234const ul = document.getElementById('list');const fragment = document.createDocumentFragment();appendDataToElement(fragment, data);ul.appendChild(fragment); 复制要更新的节点，修改节点的副本，修改完成后，再使用副本替换树上的节点。 1234const ul = document.getElementById('list');const clone = ul.cloneNode(true);appendDataToElement(clone, data);ul.parentNode.replaceChild(clone, ul); 不要频繁取样式，样式取出来后存在变量里。 优化前，每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。 12345function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px'; &#125;&#125; 优化后 123456const width = box.offsetWidth;function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + 'px'; &#125;&#125; 对于多次重排的元素，比如说动画。使用绝对定位脱离文档流，使其不影响其他元素。]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Front-end</tag>
        <tag>Browser Rendering</tag>
        <tag>Repaint&amp;Reflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apollo自动驾驶平台：订阅点云数据实现避障]]></title>
    <url>%2FApollo%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E5%B9%B3%E5%8F%B0%EF%BC%9A%E8%AE%A2%E9%98%85%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E9%81%BF%E9%9A%9C%2F</url>
    <content type="text"><![CDATA[Cyber RTApollo平台的代码在3.5版本及以后完全摒弃了ROS(Robot Operating System)，而是将整个平台基于Baidu自行研发的Cyber RT系统上。Cyber RT相较于ROS系统有以下优点： 实时性高，时延小：自动驾驶对于时延的要求十分高，而ROS系统主要针对机器人，其对时延的要求较低，这也是baidu研发Cyber RT的初衷。 调度确定性：ROS的任务调度具有不确定性，任务的执行顺序取决于系统，而Cyber RT将任务调度从内核空间移至用户空间，调度可以与算法逻辑密切结合。 Cyber RT vs ROS Cyber RT ROS 含义 Component 无 组件之间通过 Cyber channel 通信 Channel Topic channel 用于管理数据通信，用户可以通过 publish/subscribe 相同的 channel 来通信 Node Node 每一个模块包含 Node 并通过 Node 来通信。一个模块通过定义 read/write 和/或 service/client 使用不同的通信模式 Reader/Writer Publish/Subscribe 订阅者模式。往 channel 读写消息的类。 通常作为 Node 主要的消息传输接口 Service/Client Service/Client 请求/响应模式，支持节点间双向通信 Message Message Cyber RT 中用于模块间通信的数据单元。其实现基于 protobuf Parameter Parameter Parameter 服务提供全局参数访问接口。该服务基于 service/client 模式 Record file Bag file 用于记录从 channel 发送或接收的消息。 回放 record file 可以重现之前的操作行为 Launch file Launch file 提供一种启动模块的便利途径。通过在 launch file 中定义一个或多个 dag 文件，可以同时启动多个 modules Task 无 异步计算任务 CRoutine 无 协程，优化线程使用与系统资源分配 Scheduler 无 任务调度器，用户空间 Dag file 无 定义模块拓扑结构的配置文件 Apollo 代码结构整体框架Apollo 5.0 Github 开源代码 /cyber:Baidu研发的Cyber RT系统 /data /bag:可以用于放置录制的数据包，用于仿真模拟。可以通过cyber_recorder play -f /data/bag/test_filename来播放数据包 /log:保存着运行的日志文件。 /docs:大量的代码文档、操作文档、说明书等。 /docker:有关docker操作的一些脚本文件 /modules:核心模块，包含bridge、calibaration、canbus、common、contrib、control、data、dreamview、drivers、guardian、localization、map、monitor、perception、planning、prediction、routing、v2x等模块 /scripts:包含调试、运行的一些脚本。 模块的结构一个模块通常有/conf、/dag、/proto、/launch四个子目录。 /launch以下为modules/control/launch/control.launch的内容，该文件主要指示了一个dag文件。1234567&lt;cyber&gt; &lt;module&gt; &lt;name&gt;control&lt;/name&gt; &lt;dag_conf&gt;/apollo/modules/control/dag/control.dag&lt;/dag_conf&gt; &lt;process_name&gt;control&lt;/process_name&gt; &lt;/module&gt;&lt;/cyber&gt; 若是想要单独启动某一模块，如control模块，可以通过以下脚本启动。当然也可以在浏览器里Dreamview界面里打开control模块的开关来启动control模块，但在命令行以脚本启动control模块可以看到输出的日志信息，便于错误排查1cyber_luanch module/control/launch/control.launch /dagdag文件里主要指示了模块的配置文件(flag_file_path属性)，还是以control模块为例，以下为modules/control/dag/control.dag的内容1234567891011module_config &#123; module_library : "/apollo/bazel-bin/modules/control/libcontrol_component.so" timer_components &#123; class_name : "ControlComponent" config &#123; name: "control" flag_file_path: "/apollo/modules/control/conf/control.conf" interval: 10 &#125; &#125;&#125; /protoproto是协议protobuf的简写，里面定义了发布的数据格式，protobuf是google团队开发的用于高效存储和读取结构化数据的工具。 /conf里面主要包含模块的配置文件，包含了模块的一些参数，类似于在命令行执行脚本给的参数。由control.dag文件指向的主配置文件control.conf部分内容如下：123--flagfile=/apollo/modules/common/data/global_flagfile.txt--control_conf_file=/apollo/modules/control/conf/scout_conf.pb.txt--enable_speed_station_preview=false 这里的参数名可以在模块对应的common下的flags文件里定义，也可以在modules下的common模块里定义。比如control/common/目录下有control_gflags.h和 control_gflags.cc两个文件，分别用来声明参数名，和定义参数并给定参数默认值。 比如若要自定一个模块配置参数x_min，首先需要在control_gflags.h里声明：1DECLARE_double(x_min); 然后在control_gflags.cc里定义，中间参数为默认值，第三个参数为对参数的描述，类似于帮助文档：1DEFINE_double(x_min,0.0001,&quot;x min&quot;); 然后若要使用参数x_min，则可以在其他文件里include control_flags.h 这个头文件，然后通过FLAGS_x_min来使用其值，如果需要更改x_min的值，则可以在control.conf文件里修改，如将其改为-5.0，可以增加以下一行。由于这些都是命令行参数，因此修改这些值，是不需要重新编译代码的，方便调参。1--x_min=-5.0 代码编写主要更改代码的控制模块modules/control/，在控制模块通过订阅激光雷达的点云数据，获取小车正前方的的激光点云，判断若前方有障碍物则将让小车停下来。 修改control/Build文件由于要使用激光点云数据，需要额外增加依赖项，在/modules/control/Build文件里找到cc_library，在其deps数组里增加1&quot;//modules/drivers/proto:sensor_proto&quot;, sensor_proto这个库的名字可以在modules/drivers/proto/Build文件下的cc_proto_library里找到。 初始化PointCloud ReaderCyber RT采用Publish/Subscribe的通信机制，不同的模块在各自的Channel上发布Publish数据，其他模块可以通过订阅Subscribe来获取Channel上的数据。而在订阅前，当然需要先指定一个Reader，由Reader去订阅数据并读取数据。control模块已经定义了chassis_reader_用于读取车底盘的数据、localization_reader_用于读取定位数据，可以获取车辆的ENU坐标、trajectory_reader_用于获取轨迹数据等reader，接下来就可以仿照这些reader定义自己的point_cloud_reader_了。首先在modules/control/control_component.h文件里声明reader,需注意命名空间的问题。1std::shared_ptr&lt;Reader&lt;apollo::drivers::PointCloud&gt;&gt;point_cloud_reader_; 然后在modules/control/control_component.cc文件里的Init函数里对reader进行初始化：12345678// Point cload initializationcyber::ReaderConfig pointcloud_reader_config;// 设置reader的channel name，reader通过这个topic来寻找点云数据所在的channelpointcloud_reader_config.channel_name = FLAGS_lidar_16_front_center_topic;pointcloud_reader_config.pending_queue_size = FLAGS_pointcloud_pending_queue_size;// 实例化Readerpoint_cloud_reader_ = node_-&gt;CreateReader&lt;apollo::drivers::PointCloud&gt;(pointcloud_reader_config, nullptr);CHECK(point_cloud_reader_ != nullptr); FLAGS_开头的为gflags库定义的参数，gflags是使用Google的用于处理命令行参数的库，Apollo的代码里广泛运用了该库，大部分模块下都有一个/common文件夹下面有对应的gflags文件，里面定义了该模块使用的参数，使用gflags来配置模块参数的好处是更改参数后，无需编译，只需要重新启动对应模块，即可应用该参数。 FLAGS_lidar_16_front_center_topic：16线激光雷达正前方的点云数据所使用的topic名。 FLAGS_pointcloud_pending_queue_size为自定义的参数，默认值为10，设置方式参考上面设置x_min的方法。 如何找到对应的topic名呢？ velodyne.launch 首先，drivers下有一个激光的子模块velodyne，在modules/drivers/velodyne，在其launch/目录下有不同激光雷达的启动文件，由于小车使用的是16线激光雷达，所以需要16线激光雷达的启动文件，velodyne.launch为16线激光雷达的启动文件，该文件指向了一个dag文件velodyne.dag。 velodyne.dag 为了简化操作，只使用激光的正前方的数据，找到#16_front_center，其config里有一个config_file_path属性，指向了对应的配置文件velodyne16_front_center_conf.pb.txt. velodyne16_front_center_conf.pb.txt 改文件给出了对应的topic名 1convert_channel_name: &quot;/apollo/sensor/lidar16/front/center/PointCloud2&quot; 而该topic已在/modules/common/adapters/adapters_gflags.cc里定义了参数名： 123DEFINE_string(lidar_16_front_center_topic, &quot;/apollo/sensor/lidar16/front/center/PointCloud2&quot;, &quot;front center 16 beam lidar topic name&quot;); 由于代码的版本不同，可能没有该topic的FLAGS，不过可以直接用其值代替。 获取点云数据点云数据格式目前控制模块已经订阅了激光模块的点云数据，激光会通过订阅的channel发消息给控制模块，控制模块收到后需要解析该消息。 消息的格式定义在对应的proto文件里，点云消息的格式在/modules/drivers/proto/pointcloud.proto里，其内容如下：12345678910111213141516171819202122syntax = "proto2";package apollo.drivers;import "modules/common/proto/header.proto";message PointXYZIT &#123; optional float x = 1 [default = nan]; optional float y = 2 [default = nan]; optional float z = 3 [default = nan]; optional uint32 intensity = 4 [default = 0]; optional uint64 timestamp = 5 [default = 0];&#125;message PointCloud &#123; optional apollo.common.Header header = 1; optional string frame_id = 2; optional bool is_dense = 3; repeated PointXYZIT point = 4; optional double measurement_time = 5; optional uint32 width = 6; optional uint32 height = 7;&#125; 可以看到点云里面有头部header、帧id frame_d、还包括点 point 点的格式为PointXYZIT其包含x、y、z、intensity、timestamp。 点由repeated修饰，说明point可以重复，有多个，可以当作是点的数组 获取消息对应属性的数据假设收到了激光雷达发来的点云消息msg。 所有repeated修饰的属性都有大小，可以通过msg-&gt;point_size()来获取点云里点的数量。 索引点云：msg-&gt;point(i); 获取点的坐标：msg-&gt;point(i).x(); 获取数据代码思路：非常简单的障碍物识别，获取点云数据后，若在小车前进方向某一范围内有点，说明前方有障碍物，点的数量超过一定值后就让小车停下来。 为了方便调参，将范围的参数（x_min,x_max,…,z_max）全部提取出来放到control_gflags.cc文件里定义，这样就可以很方便的在control.conf文件里面修改了。 注意：小车的正前方为为x的正方向、左方为y的正方向、上方为Z的正方向。12345678910111213141516171819202122232425// 开始监听channel上的数据point_cloud_reader_-&gt;Observe();// 获取最近收到的数据const auto &amp;point_cloud_msg = point_cloud_reader_-&gt;GetLatestObserverd();int point_num = 0;for( int i = 0; i &lt; point_cloud_msg-&gt;point_size(); ++i)&#123; float x = point_cloud_msg-&gt;point(i).x(); float y = point_cloud_msg-&gt;point(i).y(); float z = point_cloud_msg-&gt;point(i).z(); if( x &gt; FLAGS_x_min &amp;&amp; x &lt; FLAGS_x_max &amp;&amp; y &gt; FLAGS_y_min &amp;&amp; y &lt; FLAGS_y_max &amp;&amp; z &gt; FLAGS_z_min &amp;&amp; z &lt; FLAGS_z_max)&#123; point_num++; &#125; if(point_num&gt;20)&#123; std::cout&lt;&lt; "Obstacle detected. set vehicle speed to zero."&lt;&lt;std::endl; // 设置车速为0 control_command.set_speed(0.0); // 设置车的角速度为0 control_command.set_angular_velocity(0.0); &#125;&#125; 到此，代码就完成了。将代码编译1bash apollo.sh build 编译通过后就可以上车测试了。 仿真测试若没有小车进行实测，可以先用录制的bag数据进行仿真测试。 播放数据 1cyber_recorder play -f /data/bag/test.00000 启动控制模块 1cyber_launch modules/control/launch/control.launch 或者 1bash control.sh start_fe 注意：AINFO/ADEBUG打印输出的内容在控制台上看不到，需要用std::cout打印输出。由于没有和小车相连，对应的车地盘数据获取不到，会出现chassis msg not ready的错误信息，这不影响。 上车测试 首先录制一条小车运行的轨迹 让小车自己跑起来，测试小车会不会在遇到障碍物后停下来 注意：这里可以用仿真测试里的命令行的形式启动control模块，而不是在dreamview里打开control模块的开关，这样可以方便查看控制台日志信息。 实操效果 The `` tag is not supported by your browser.]]></content>
      <categories>
        <category>Autonomous Driving</category>
      </categories>
      <tags>
        <tag>Autonomous Driving</tag>
        <tag>Baidu Apollo</tag>
        <tag>PointCloud</tag>
        <tag>Lidar</tag>
        <tag>Obstacle Detection</tag>
        <tag>protobuf</tag>
        <tag>Cyber RT</tag>
        <tag>ROS</tag>
        <tag>gflags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apollo自动驾驶平台：循迹]]></title>
    <url>%2FApollo%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E5%B9%B3%E5%8F%B0%EF%BC%9A%E5%BE%AA%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[线性二次调节器LQR线性二次调节器（Linear Quadratic Regulator 或LQR）是基于模型的控制器，它通过控制车辆状态来使小车运动的横向误差和朝向误差最小化。Apollo使用LQR进行横向控制。横向控制包含四个参数：横向误差 $cte$、横向误差变化率 $\dot{cte}$、朝向误差 $\theta$和朝向误差变化率 $\dot{\theta}$，这四个参数构成1×4的列向量$x$。变化率与导数相同，用变量名上面的一个点来代表。该车有三个控制输入：转向、加速和制动,这个三个控制输入集合称为$u$。 $x$和$u$与自身相乘，这样负值也会产生正平方，为每个二次项分配权重，并将它们加在一起。 w_1cte^2+w_2\dot{cte}^2+w_3\theta^2+w_4\dot{\theta}^2+w_5*steering^2+w_6*throttle^2+w_7*brake^2最优的$u$应该最小化二次项的和随时间的积分。 cost=\int_{0}^{\infty}(x^TQx+u^TRu)dt$Q$和$R$代表$x$和$u$的权重集合。$x^T$和$u^T$是转置矩阵，这意味着它们几乎与$x$和$u$相同，只是重新排列以便矩阵相乘。$x$乘以$x^T$，$u$乘以$u^T$，实质上是将每个矩阵乘以它自己。$Q$在Apollo代码中对应modules/control/conf/scout_conf.pb.txt文件下的下面配置参数1234matrix_q: 0.001matrix_q: 0.0matrix_q: 0.01matrix_q: 0.0 $R$则对应1r: 0.00001 循迹过程中可以修改以上参数以使得小车更加稳定地进行循迹。 在LQR中，控制方法被描述为$u=-Kx$。其中，$K$代表一个复杂的skeme，代表如何从$x$计算出$u$。所以找到一个最优的u就是找到一个最优的$K$。 循迹操作流程 将操作者电脑连接至开发套件（小车）的无线网络中（小车自带一个路由） 操作电脑使用ssh远程登录至小车，若是直接在小车的系统上进行操作可以免去步骤1和2. 进入到apollo代码的根目录下，启用docker环境, 并进入docker环境 12bash docker/scripts/dev_start.shbash docker/scripts/dev_into.sh 启动DreamView，执行bootstrap.sh脚本 1bash scripts/bootstrap.sh 在浏览器中打开DreamView，输入小车的IP地址:8888即可（若是在小车系统上，直接用localhost:8888即可访问）。 在Module Controller下打开CAN Bus、Localization、GPS. 注意： 为保证可以接受到GPS信号，尽量在开阔处进行测试。 若有修改参数，无需重新编译代码，直接将对应的模块重新打开一下即可。 注意观察Task菜单下的Module Delay，若出现红色的延时，重新打开一下对应的模块。 将小车停至合适的位置（想要循迹的初始位置），操作者将Module Controller下的data recorder（录制运行时的数据）和RTK recorder（录制轨迹）打开后，就可以开始使用遥控器操控小车行驶来录制轨迹数据了。 录制完毕后，将data recorder、RTK recorder模块关闭，将小车停至循迹的初始点，打开Module Controller下的RTK replay、control，用遥控器将小车切入自动驾驶模式。然后在DreamView下的Task菜单下点击Start Auto，小车便可以开始自动循迹。 注意：循迹期间需密切关注小车的行驶情况，遇险时应立即使用遥控接管或拍下小车后面的急停按钮。]]></content>
      <categories>
        <category>Autonomous Driving</category>
      </categories>
      <tags>
        <tag>Autonomous Driving</tag>
        <tag>Buido Apollo</tag>
        <tag>Tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apollo自动驾驶平台：工控机软件系统安装教程]]></title>
    <url>%2FApollo%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E5%B9%B3%E5%8F%B0%EF%BC%9A%E5%B7%A5%E6%8E%A7%E6%9C%BA%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介此系列博客将记录如何使用百度Apollo自动驾驶开发者套件完成循迹功能。循迹指的是让车辆/机器人自己照着原来设定的路线行驶，因此首先要进行录制路线Record，然后再进行循迹Replay，以及完成简单的避障功能。 Apollo的开发者套件，也就是一辆小车，如下图所示, 拥有一个激光雷达，两个GPS天线，一个IMU，一个毫米波雷达，3个摄像头用于感知环境，小车同时配备一个遥控器用于控制小车，小车有两种模式：遥控模式和自动驾驶模式。 工控机软件系统安装Ubantu系统安装由于Apollo平台的代码均基于Linux，因此需要安装一个Linux系统，此处推荐Ubantu，官方用的也是Ubantu系统，官方教程推荐的是Ubantu14.04.3系统，但此系统较老旧，可能出现一些奇怪的问题（比如无法上网），因此还是推荐使用Ubantu16.04. 下面部分是Ubantu双系统的安装，使用虚拟机的话需要保证配置，不然跑不起来代码，至少需要给Ubantu系统分配70G的存储空间，据说两核至少需要8小时才可以编译Apollo平台。 软件准备 Ubantu16.04 引导盘制作软件链接: https://pan.baidu.com/s/12KEntHWK8RZ1wSnVE6Aatw 提取码: 7vvb 步骤 引导盘制作可以参考教程. 磁盘分区 在“我的电脑”上右键单击，点“管理”。 进入下面界面后，点“存储-&gt;磁盘管理”。 选择一个空间足够(&gt;=70G,最好100G)的非系统盘，右键单击，选择压缩卷。 在查询完可用压缩空间后，会弹出下列对话框，输入想要压缩的空间,然后点击确认即分区完成（压缩的空间也就是预留给Ubantu的存储空间） Ubantu安装 将启动盘插入电脑 重启电脑，并尝试进入BIOS系统，进入方式不同电脑不一样，通常进入方式为F12/F2/DEL/Enter这几个键，可以多重启几次几个键都试试。重启后疯狂敲这些键就好啦。 进入后，选择USB启动，然后选择Ubantu即可进入Ubantu系统的安装向导。 然后照着向导依次选择语言、时区等等就OK啦。 注意：Ubantu安装时，会要求填用户名和密码，这个密码一定要牢记，后面获取root权限需要该密码。 Docker安装只需在Ubantu里运行Apollo提供的脚本即可，脚本链接1bash ./install_docker.sh Apollo源代码编译首先获取Apollo源代码，约1G左右，下载时间较长，耐心等待。 1git clone https://github.com/ApolloAuto/apollo.git 下载完后，cd进入代码的根目录下，依次执行以下脚本，执行时间较长。 123bash docker/scripts/dev_start.sh bash docker/scripts/dev_into.shbash apollo.sh build 编译完成后，执行下面命令打开DreamView交互平台。 1bash scripts/bootstrap.sh 启动成功的提示信息： 1234Start roscore...Launched module monitor.Launched module dreamview.Dreamview is running at http://localhost:8888 在浏览器上访问http://localhost:8888，即可打开DreamView。DreamView界面如下所示： 到此环境就配置完毕, 下一个教程介绍如何使用DreamView完成循迹 参考Apollo开源代码git仓库的官方教程。]]></content>
      <categories>
        <category>Autonomous Driving</category>
      </categories>
      <tags>
        <tag>Environment Setup</tag>
        <tag>Autonomous Driving</tag>
        <tag>Baidu Apollo</tag>
        <tag>Multiple Operating System</tag>
        <tag>Ubantu</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 强缓存vs弱缓存]]></title>
    <url>%2F%E5%BC%BA%E7%BC%93%E5%AD%98vs%E5%BC%B1%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[HTTP缓存类型 强缓存（本地缓存） 弱缓存（协商缓存） 流程访问静态资源时的流程 强缓存阶段：先在本地查找是否有该资源，若有，且Expires和Cache-Control都满足要求，则命中强缓存，返回200，直接返回强缓存中的数据，不会向服务器发出请求。 弱缓存阶段：在本地缓存找到该资源，发送http请求到服务器询问该资源是否有更新，若服务器判断没有更新，返回304Not Modified。则浏览器继续使用该资源。 缓存失败阶段：若在本地没有找到对应资源，或者资源已过期/更新，则服务器返回该资源。 强缓存VS弱缓存 状态码 强缓存返回200 弱缓存返回304 强缓存不需要发出http请求，而弱缓存需要。 强缓存使用Expires和cache-control来控制。优先级：pragma&gt;cache-control&gt;Expires Expires 服务器为资源设置一个Expire日期，在这Expire日期之前可以将资源视作最新。此字段是为了兼容旧版本HTTP才保留的，在http1.0时配合pragma使用，pragma：no-cache表示不缓存，pragma的优先级大于Expires Cache-Control Cache-Control是http1.1为了弥补Expires的缺陷而加入的（http1.0时，使用pragma），当Expires和Cache-Control同时存在时，Cache-Control的优先级高于Expires。 Cache-Control取值 描述 public 服务器端和浏览器端都可以缓存 private 只有浏览器可以缓存 no-cache 强制浏览器在使用cache拷贝之前先提交一个http请求到原服务器进行确认，类似于弱缓存 only-if-cached 表明客户端只接受已缓存的响应，并且不需要向服务器检查是否有更新的拷贝 max-age=60 单位：秒，缓存的有效期，超过这个时间后将被认为过期。此选项会覆盖Expires字段的过期日期 no-store 不缓存，使用协商缓存 must-revalidate 缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源 弱缓存有关字段 Last-Modified/If-Modified-Since（HTTP1.0）、Etag/If-None-Match（HTTP1.1） Last-Modified和Etag为响应头部字段，分别对应请求头部字段中的if-Modifed-Since/If-None-Match。 Last-Modified/If-Modified-Since存在缺陷，当资源的实际内容没有改变而仅仅只是时间变化了（比如只是打开了文件，并保存了一下，尽管内容没有变化但还是修改过），还是需要重新请求资源。因此为了解决这个缺陷，http1.1提出了Etag/If-None-Match，Etag类似于文件的hash，为文件提供了一个指纹，只检查文件内容是否一致。 流程： 当没有命中强缓存时，进入弱缓存阶段 浏览器首次访问网站时，服务器会在响应头部中附上Last-Modified/Etag 弱缓存阶段，浏览器再次访问时，会发送If-Modified-Since/If-None-Match去询问是否有改变，有则重新获取，否则使用本地缓存。 缓存与浏览器刷新 F5刷新，会使强缓存失效，浏览器进行协商缓存。 Ctrl+F5刷新，为强制刷新，强缓存与弱缓存均失效，浏览器总会发送HTTP请求向服务器获取最新数据。]]></content>
      <categories>
        <category>Computer Network</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
        <tag>HTTP</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：清除浮动的方法]]></title>
    <url>%2FCSS%EF%BC%9A%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[CSS 浮动 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 浮动属性的本意是：让文字像流水一样环绕浮动元素 特点包裹性对于父元素而言，通常宽度默认为100%，高度适应内容，而对父元素使用float之后，父元素的宽度也会自适应内容，将内容包裹起来。 对应的代码如下12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; .div1 &#123; background:#000080; border:1px solid red; float: left; &#125; .left &#123; width:200px; height:200px; background:#DDD; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="div1"&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 高度塌陷使用float属性之后，浮动元素脱离文档的普通流，他的父级元素无法获得浮动元素的高度，因而错误的认为里面没有元素，因而出现高度塌陷问题。 对应代码如下12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; .div1 &#123; background:#000080; border:1px solid red; &#125; .left &#123; width:200px; height:200px; background:#DDD; float:left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="div1"&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 清除浮动为了避免高度塌陷的问题，可以通过多种方式清除浮动 一、父元素固定height既然是父元素高度塌陷，那么最简单直接的方式是将父元素的高度固定下来。但这种方式缺乏灵活性，适合固定高度的布局。 二、空标签+clear:both在父级元素里面添加一个空的div标签，并设置div标签的clear属性为both。该方法的浏览器支持性较好，但是当浮动布局元素较多时，需要很多空div标签，因此不推荐使用。代码：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; .div1 &#123; background:#000080; border:1px solid red; &#125; .left &#123; width:200px; height:200px; background:#DDD; float:left; &#125; .clearfloat&#123;clear:both&#125; /* new */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="div1"&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;/div&gt; &lt;div class="clearfloat"&gt;&lt;/div&gt; &lt;!--new--&gt; &lt;/body&gt;&lt;/html&gt; 效果： 三、父级元素添加overflow直接为父级元素添加属性overflow，设置值为hidden或auto即可。此方法的原理是利用overflow:auto来触发BFC（块级格式化上下文），而在BFC渲染区域内，盒子的排布会呈现一定的规则，其中一条就是BFC在计算高度时，会算上浮动元素的高度，因此可以用出发BFC的方式来清除浮动。 hidden：缺点是无法和position一起使用，超出的部分会被隐藏掉。 auto: 缺点是当子元素高度大于父元素时，会出现滚动条。 四、定义伪元素 ::after 兼容性：IE8以上才支持::after 目前主流采用此方法，浏览器兼容较好，推荐使用此方法解决浮动问题。伪元素::after用于在CSS选择器选中的元素后面创建一个伪元素,该元素在显示上类似于真实的元素,只是不会出现在dom树上. 清除浮动的原理与第一种方法相同,相当于在浮动元素后面增加了一个clear:both的空元素. 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; .div1 &#123; background:#000080; border:1px solid red; &#125; .left &#123; width:200px; height:200px; background:#DDD; float:left; &#125; /* solution */ .clearfloat::after&#123; /* 伪元素默认为行内元素 */ display:block; /* 清除浮动 */ clear:both; /* 设置伪元素的内容,可以为任意值 */ content:"."; /* 不让伪元素显示出来 */ visibility:hidden; height:0 &#125; .clearfloat&#123; /* 触发 hasLayout,为了兼容IE6,IE7 */ zoom:1 &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="div1 clearfloat"&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String Matching Algorithm——Sunday]]></title>
    <url>%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E2%80%94Sunday%2F</url>
    <content type="text"><![CDATA[算法比较对长为m的源串，长为n的子串进行匹配 算法 最坏时间复杂度 最优时间复杂度 暴力双循环 O(m*n) \ KMP O(m+n) \ Sunday O(m*n) O(m/n) KMP算法 核心:充分利用已知的信息，通过构建部分匹配表（Partial Match Table）来控制匹配位。 可参考以下Youtube视频： 虽然懂了KMP的大概思路，但写出来的代码还是一堆bug呀，果然还是功力不够，不过还好有Sunday算法，简单易懂，速度又快！ Sunday算法Sunday算法是对BM算法（Boyer-Moore算法）的进一步优化，是现代文字处理器中常用的字符串匹配算法。 核心：尽可能的跳过较多的字符串 参数介绍： 主串S 模式串P i 为主串S的的index，j为模式串P的index。 m 指着模式串最后一位与主串对应的位置的下一位（现在不理解，可以看下面的实例）。 slen：主串S的长度 plen: 模式串P的长度 算法步骤 首先初始状况是i=j=0，i指着S的首位，j指着P的首位，m则指着S的第plen+1位，及第6位 判断S[i]与P[j]是否相等。 若相等则i++，j++，比较下一位。 若相等，且j==plen-1，也就是比较完毕了，则说明找到了目标，直接返回i-j即可。 若是不相等，则需要看S[m]字符是否在P中出现 若没出现，则直接将j指向S[m]的下一位，i指向m+1的位置，j则重新置0，m则更新为 新的i+plen。 若出现了，还是要想办法尽可能大的将P往后滑动。首先，找到模式串P中与S[m]字符相等字符的位置，然后将P串中的该字符与S[m]字符对齐。对齐时，P向右滑动了多少格，i更新的时候就加几，j则重置为0，m还是用更新后的i加plen：新i+plen。 更新后若出现m&gt;slen的情况，说明已经比较完毕，仍没有找到目标，则return -1。 实例讲解参数 S: string matching algorithm P: rithm slen: 25 plen: 5 首先将i指向S首位，j指向P首位，即i=j=0. m则指向S的第plen位，也就是第5位。 初始化 i=0, j=0, m=5， 状态如下所示 S s t r i n g m a t c h i n g a l g o r i t h m i m P r i t h m j 比较 S[0] 与 P[0]，发现不等，则直接看 S[5] 是否在P中出现，&#39;rithm&#39;里是没有&#39;g&#39;的，故直接将P移到m的下一位。 第一步更新后 i=6, j=0, m=11， 状态如下所示 S s t r i n g m a t c h i n g a l g o r i t h m i m P r i t h m j 比较S[6]与P[0]，发现&#39; &#39;不等于&#39;r&#39;，且S[11]在&#39;rithm&#39;的第3位出现。则需要将P中的&#39;h&#39;与S中的&#39;h&#39;对齐，只需要将P串向右移动两格（对应于i=m-3=8） 第二步更新后 i=8, j=0, m=13， 状态如下所示 S s t r i n g m a t c h i n g a l g o r i t h m i m P r i t h m j 同样S[8]!=P[0]，且S[13]为&#39;n&#39;不存在于&#39;rithm&#39;，因此直接将P滑到m的下一位 第三步更新后 i=14, j=0, m=19 S s t r i n g m a t c h i n g a l g o r i t h m i m P r i t h m j 再次比较, S[14]!=P[0], 且S[19]不在P中，再次将P滑到m的下一位。 第四步更新后 i=20, j=0, m=25 S s t r i n g m a t c h i n g a l g o r i t h m i m P r i t h m j 这时候可以看到，&#39;rithm&#39;是匹配上了，一步一步比较，i与j逐步加1，直至j=4时，比较完毕，得到结果i-j=24-4=20。 LeetCode 题源LeetCode 28. Implement strStr() AC 代码1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int strStr(string haystack, string needle) &#123; if(needle.empty())&#123; return 0; &#125; int slen=haystack.length(); int plen=needle.length(); int i=0,j=0,k,m=plen; // i 指 haystack，j 指 needle， while(i&lt;slen)&#123; if(haystack[i]!=needle[j])&#123; for(k=plen-1;k&gt;=0;k--)&#123; if(needle[k]==haystack[m]) break; &#125; i=m-k; j=0; m=i+plen; if(m&gt;slen)&#123; return -1; &#125; &#125;else&#123; if(j==plen-1)&#123; return i-j; &#125; i++,j++; &#125; &#125; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>Data Structure &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Sunday</tag>
        <tag>String Matching</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript Prototype]]></title>
    <url>%2FJavascript-Prototype%2F</url>
    <content type="text"><![CDATA[构造函数每个实例都有一个constructor属性，指向他的构造函数。每一个原型对象都有一个默认的属性constructor。每一个constructor都指向一个原型对象。 JS 原型（prototype）Javascript对象可以从原型对象继承属性，这种原型式继承(prototypal inheritance)是Javascript的核心。原型中定义的函数只在JavaScript加载时被创建一次，创建的每个对象都可以调用原型中的方法。 每个Javascript函数都有一个prototype属性（Function.bind()除外） 每个对象有一个proto属性指向该对象constructor.prototype，但只有函数才有prototype属性 以上面Book类为例, 原型、构造函数和实例对象的关系如下图所示： 即：1234var book1=new Book("Harry Potter","J.K.Rowling");book1.__proto__===Book.prototype; // truebook1.constructor===Book //trueBook.prototype.constructor===Book // true 所有的函数对象都继承自Function.prototype,因此有：12345678910111213141516171819202122232425262728Number.__proto__ === Function.prototype // trueNumber.constructor == Function //trueBoolean.__proto__ === Function.prototype // trueBoolean.constructor == Function //trueString.__proto__ === Function.prototype // trueString.constructor == Function //true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype // trueObject.constructor == Function // true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // trueFunction.constructor == Function //trueArray.__proto__ === Function.prototype // trueArray.constructor == Function //trueRegExp.__proto__ === Function.prototype // trueRegExp.constructor == Function //trueError.__proto__ === Function.prototype // trueError.constructor == Function //trueDate.__proto__ === Function.prototype // trueDate.constructor == Function //true 而Math与JSON以对象形式存在，所以：12345Math.__proto__ === Object.prototype // trueMath.construrctor == Object // trueJSON.__proto__ === Object.prototype // trueJSON.construrctor == Object //true 再一个例子12345678function Person()&#123;&#125;var person1 = new Person();console.log(person1.__proto__ === Person.prototype); // trueconsole.log(Person.prototype.__proto__ === Object.prototype) //trueconsole.log(Object.prototype.__proto__) //nullPerson.__proto__ == Function.prototype; //trueconsole.log(Function.prototype)// function()&#123;&#125; (空函数) 注意： 大部分prototype都是object类型，但Function.prototype是function类型。 Object.prototype.proto=null 由于Object是所有类的父类，类似于根节点，所以其prototype的proto为null。 当试图引用某对象的某属性时，首先会在该对象的内部查找是否有该属性，找不到，就会去对象的proto属性里找，接着又会在proto属性所指的对象的proto里查找，一直查到Object的Protot。 instanceof 运算符左侧为待测的实例对象，右侧为构造函数（构造函数即类名，是类的共有标识）。instanceof会检查左侧对象是否继承自右侧构造函数的prototype对象。可以不是直接继承。 参考https://www.jianshu.com/p/dee9f8b14771]]></content>
      <categories>
        <category>Front-end</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Prototype</tag>
        <tag>Object Oriented Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux:Swap File Usage]]></title>
    <url>%2FLinux-Swap-File-Usage%2F</url>
    <content type="text"><![CDATA[起因最近在使用pip安装torch时，由于内存不足，导致了Memory Error。pip安装的缓存机制想要先把整个文件读取到内存以后才开始安装，因此可能导致内存不足。 解决方案 方案一 不缓存 1pip --no-cache-dir install xxx 方案二 使用Swap File启动swap文件，swap文件在硬盘上开辟一段空间，作为虚拟内存。操作系统会把使用频率低的内容，暂时存放到swap文件内，需要使用时再调用到内存中。启动方法，在任意目录下执行以下命令 123456# 创建一个512 MB大小的swap文件，大小根据你的需要设置dd if=/dev/zero of=/swapfile bs=1024 count=524288chown root:root /swapfilechmod 0600 /swapfilemkswap /swapfileswapon /swapfile 完成以上指令后，再次尝试使用pip install xxx 即可成功安装。 若出现以下错误：1dd: failed to open ‘/swapfile’: Text file busy 这是因为swapfile处于启动状态，可能正在被使用，因此需要先关掉swapfile：1swapoff /swapfile]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Swap File</tag>
        <tag>Memory Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pascal VOC 数据集格式详解]]></title>
    <url>%2FPascal-VOC-%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简介Pascal Voc 格式是目标检测常用的格式。Pascal Voc 数据集官网 目录结构PASCAL VOC数据集由5个部分构成：JPEGImages，Annotations，ImageSets，SegmentationClass以及SegmentationObject。 JPEGImages：存放的是训练与测试的所有图片。 Annotations：里面存放的是每张图片打完标签所对应的XML文件 ImageSets：ImageSets文件夹下本次讨论的只有Main文件夹，此文件夹中存放的主要又有四个文本文件test.txt,train.txt,trainval.txt,val.txt,其中分别存放的是测试集图片的文件名、训练集图片的文件名、训练验证集图片的文件名、验证集图片的文件名。 SegmentationClass与SegmentationObject：存放的都是图片，且都是图像分割结果图，对目标检测任务来说没有用。class segmentation 标注出每一个像素的类别 。object segmentation 标注出每一个像素属于哪一个物体 Annotation的Xml格式1234567891011121314151617181920212223242526&lt;annotation&gt; &lt;folder&gt;17&lt;/folder&gt; # 图片所处文件夹 &lt;filename&gt;77258.bmp&lt;/filename&gt; # 图片名 &lt;path&gt;~/frcnn-image/61/ADAS/image/frcnn-image/17/77258.bmp&lt;/path&gt; &lt;source&gt; #图片来源相关信息 &lt;database&gt;Unknown&lt;/database&gt; &lt;/source&gt; &lt;size&gt; #图片尺寸 &lt;width&gt;640&lt;/width&gt; &lt;height&gt;480&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;segmented&gt;0&lt;/segmented&gt; #是否有分割label &lt;object&gt; 包含的物体 &lt;name&gt;car&lt;/name&gt; #物体类别 &lt;pose&gt;Unspecified&lt;/pose&gt; #物体的姿态 &lt;truncated&gt;0&lt;/truncated&gt; #物体是否被部分遮挡（&gt;15%） &lt;difficult&gt;0&lt;/difficult&gt; #是否为难以辨识的物体， 主要指要结体背景才能判断出类别的物体。虽有标注， 但一般忽略这类物体 &lt;bndbox&gt; #物体的bound box &lt;xmin&gt;2&lt;/xmin&gt; &lt;ymin&gt;156&lt;/ymin&gt; &lt;xmax&gt;111&lt;/xmax&gt; &lt;ymax&gt;259&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt;&lt;/annotation&gt; LabelImg用于对图片打标签的软件，可以生成Pascal Voc格式的Xml文件。LabelImg百度云下载链接。 制作Pascal VOC格式的数据集 爬取数据集图片放置于JPEGImages文件夹下，注意文件命名（按顺序递增）。 使用LabelImg进行标注，获取对应图片的XML标注文件，放置于Annotations文件夹下。 运行如下代码生成ImageSets文件夹12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# @Time : 2018/11/12 13:03# @Author : lazerliu# @File : xml2voc.pyimport osimport random# ==================可能需要修改的地方=====================================#g_root_path = "D:/VOCdevkit/VOC2007/" #根路径xmlfilepath = "Annotations" # 标注文件存放路径saveBasePath = "ImageSets/Main/" # ImageSets信息生成路径trainval_percent = 0.98train_percent = 0.98# ==================可能需要修改的地方=====================================#os.chdir(g_root_path)total_xml = os.listdir(xmlfilepath)num = len(total_xml)xml_list = range(num)tv = int(num * trainval_percent)tr = int(tv * train_percent)trainval = random.sample(xml_list, tv)train = random.sample(trainval, tr)print("train and val size", tv)print("train size", tr)ftrainval = open(saveBasePath + "trainval.txt", "w")ftest = open(saveBasePath + "test.txt", "w")ftrain = open(saveBasePath + "train.txt", "w")fval = open(saveBasePath + "val.txt", "w")for i in xml_list: name = total_xml[i][:-4] + "\n" if i in trainval: ftrainval.write(name) if i in train: ftrain.write(name) else: fval.write(name) else: ftest.write(name)ftrainval.close()ftrain.close()fval.close()ftest.close()]]></content>
      <categories>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>Pascal VOC</tag>
        <tag>Dataset Format</tag>
        <tag>Computer Vision</tag>
        <tag>Object Detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to access server with Jupyter Notebook]]></title>
    <url>%2Fconnect-server-with-jupyter%2F</url>
    <content type="text"><![CDATA[安装Jupyter首先登录服务器，输入jupyter notebook检查是否有安装过jupyter。若没有则通过以下指令安装：1pip install jupyter 生成Jupyter配置文件安装完Jupyter之后，输入以下指令生成jupyter配置文件：1jupyter notebook --generate-config 配置文件默认会放置在Writing default config to:/root/.jupyter/jupyter_notebook_config.py 生成密钥 命令行输入ipython。1$ ipython import passwd包，使用改包生成密钥12345In[1]: from notebook.auth import passwdIn[2]: passwd()Enter password: Verify password: Out[2]: 'sha1:0000000000000000000000000000000000000000000000000' 编辑jupyter配置文件输入以下指令，编辑配置文件1vim ~/.jupyter/jupyter_notebook_config.py 按i进入编辑模式该文件的所有配置初始时都是被注释的。需要修改以下的配置，将每一行配置前的＃去掉123456c.NotebookApp.allow_remote_access = Truec.NotebookApp.allow_root = True ## 表示是否允许jupyter使用root权限c.NotebookApp.ip = '*'c.NotebookApp.port = 8888 ##根据自己情况指定c.NotebookApp.open_browser = Falsec.NotebookApp.password = u'sha1:00000000....' ## 刚刚设置密码时生成的密钥 编辑完成后按esc退出编辑模式，输入‘:wq’退出编辑。 后台运行jupyter[后台运行参考]完成以上步骤以后，只需要在后台将jupyter运行起来就OK啦：1nohup jupyter notebook &amp; Note: 注意以上运行jupter指令所在的目录，该目录会作为访问时的根目录。 这时当前目录下会生成一个nohup.out文件，运行jupyter notebook的所有标准输出都会重定向至该文件内。可使用1jobs 查看后台作业的情况。若目录不正确可以使用kill中止掉后台进程，进入到期望的目录下后再次运行1kill %使用jobs查询到的作业代号 访问远程服务器的Jupyter在自己的浏览器上输入1服务器ip:端口号 即可进入jupyter的登录页面，如下所示接下来输入刚刚设置的密码，即可通过jupyter访问服务器啦！]]></content>
      <categories>
        <category>Data Science</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
        <tag>Deployment</tag>
      </tags>
  </entry>
</search>
